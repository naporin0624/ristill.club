---
description: 
globs: 
alwaysApply: true
---
# グローバル開発規約

## Immutable Programming Rules

### Variable Declaration
- **NEVER use `let` keyword**: All variables must be declared with `const`
- Use immutable patterns: conditional expressions, IIFE, or helper functions instead of reassignment

### Examples

#### ❌ Bad (using let)
```typescript
let value: number | undefined;
if (condition) {
  value = calculateValue();
}
```

#### ✅ Good (immutable)
```typescript
const value = condition 
  ? calculateValue() 
  : undefined;

// Or using IIFE for complex logic
const value = (() => {
  if (complexCondition) {
    return calculateComplexValue();
  }
  return defaultValue;
})();
```

### Additional Rules
- Use readonly arrays and objects when possible
- Prefer map, filter, reduce over for loops with mutations
- Use spread operator for object/array updates instead of direct mutation
- Consider using libraries like Immer for complex state updates

### Rationale
This project follows immutable programming principles to:
- Reduce bugs related to unexpected state mutations
- Improve code predictability and debugging
- Enable better optimization opportunities
- Align with functional programming best practices

## Array Access Guidelines

### Safe Array Access Patterns
- **Use `at()` method or destructuring assignment for array access**
- Always use type guards for type narrowing after array access
- Avoid direct bracket notation when the element might be undefined

### Examples

#### ❌ Bad (unsafe array access)
```typescript
const firstItem = array[0]; // might be undefined
const lastItem = array[array.length - 1]; // might be undefined
```

#### ✅ Good (using destructuring with type guard)
```typescript
const [firstItem] = array;
if (firstItem !== undefined) {
  // Type is narrowed, safe to use firstItem
  console.log(firstItem.property);
}
```

#### ✅ Good (using at() with type guard)
```typescript
const firstItem = array.at(0);
if (firstItem !== undefined) {
  // Type is narrowed, safe to use firstItem
  console.log(firstItem.property);
}

const lastItem = array.at(-1);
if (lastItem !== undefined) {
  // Type is narrowed, safe to use lastItem
  console.log(lastItem.property);
}
```

### Rationale
This approach:
- Prevents runtime errors from accessing undefined array elements
- Provides better type safety through TypeScript's type narrowing
- Makes code more explicit about handling potential undefined values

## Non-Null Assertion Guidelines

### Strict No Non-Null Assertion Policy
- **NEVER use non-null assertion operator (`!`)**
- Use proper type guards, optional chaining, or nullish coalescing instead
- Configure ESLint rules to enforce this restriction when possible

### Examples

#### ❌ Bad (using non-null assertion)
```typescript
const user = getUser()!; // Dangerous assumption
const name = user.profile!.name!; // Multiple dangerous assumptions
```

#### ✅ Good (using type guards and optional chaining)
```typescript
const user = getUser();
if (user !== undefined) {
  const name = user.profile?.name;
  if (name !== undefined) {
    // Safe to use name
    console.log(name);
  }
}

// Or using nullish coalescing for defaults
const name = user?.profile?.name ?? 'Unknown';
```

### Rationale
This policy:
- Prevents runtime errors from null/undefined access
- Forces explicit handling of potentially null/undefined values
- Improves code reliability and maintainability
- Aligns with defensive programming practices

## Naming Conventions

### File and Directory Naming
- **ALL files and directories MUST use kebab-case**
- Use lowercase letters and hyphens only
- Be descriptive but concise

#### Examples

##### ✅ Good (kebab-case)
```
src/
├── components/
│   ├── user-profile/
│   │   ├── index.tsx
│   │   ├── styles.css.ts
│   │   └── user-profile.test.tsx
│   ├── event-card/
│   │   ├── index.tsx
│   │   ├── styles.css.ts
│   │   └── event-card.test.tsx
├── app/
│   ├── event-details/
│   │   ├── page.tsx
│   │   ├── styles.css.ts
│   │   └── _components/
│   │       └── event-info-section/
│   │           ├── index.tsx
│   │           ├── styles.css.ts
│   │           └── event-info-section.test.tsx
```

##### ❌ Bad (camelCase, PascalCase, snake_case)
```
src/
├── components/
│   ├── UserProfile/          # ❌ PascalCase
│   ├── eventCard/           # ❌ camelCase  
│   ├── user_profile/        # ❌ snake_case
```

### Component and Function Naming
- **Components**: Use PascalCase for React components
- **Functions and variables**: Use camelCase
- **Constants**: Use UPPER_SNAKE_CASE for module-level constants
- **Types and interfaces**: Use PascalCase

#### Examples

##### ✅ Good
```typescript
// Constants
const API_BASE_URL = 'https://api.example.com';
const MAX_RETRY_COUNT = 3;

// Types
type User = {
  id: string;
  name: string;
};

interface EventService {
  create(event: Event): Promise<Event>;
  update(id: string, data: Partial<Event>): Promise<Event>;
}

// Components
const UserProfile = ({ user }: { user: User }) => {
  return <div>{user.name}</div>;
};

// Functions
const calculateEventDuration = (start: Date, end: Date): number => {
  return end.getTime() - start.getTime();
};
```

### Namespace Separation for Complex Names
- **Methods and functions within namespaces should avoid three or more word combinations**
- Namespace containers (classes, interfaces, factory functions) can have longer descriptive names
- Limited scopes include: `_components`, `internal`, and similar restricted contexts where longer names are acceptable
- Consider directory separation to simplify implementation and improve readability
- **AVOID using TypeScript `namespace` directive as it is deprecated**

### Avoid Redundant Type Information in Naming
- **Do not include obvious type information in variable names**
- Avoid suffixes like `Observable` for RxJS observables, `Component` for React components, etc.
- Let TypeScript's type system provide type information instead of encoding it in names

#### Examples

##### ❌ Bad (redundant type information)
```typescript
// RxJS Observables
const userDataObservable = new Observable<User>();
const clickEventObservable = fromEvent(button, 'click');

// React Components
const UserProfileComponent = () => <div>Profile</div>;
const NavigationBarComponent = () => <nav>Navigation</nav>;

// Other types
const userArray = [user1, user2, user3];
const configObject = { theme: 'dark', lang: 'en' };
```

##### ✅ Good (concise naming without type redundancy)
```typescript
// RxJS Observables - type is clear from context and TypeScript
const userData = new Observable<User>();
const clickEvent = fromEvent(button, 'click');

// React Components - JSX usage makes component nature obvious
const UserProfile = () => <div>Profile</div>;
const NavigationBar = () => <nav>Navigation</nav>;

// Other types - TypeScript provides type information
const users = [user1, user2, user3];
const config = { theme: 'dark', lang: 'en' };
```

## Loop Implementation Guidelines

### Loop Patterns
- **AVOID `forEach()` method**: Use `for...of` or `for...in` loops instead
- Prefer modern loop constructs for better performance and readability
- Use `for...of` for iterating over values
- Use `for...in` for iterating over object keys

### Examples

#### ❌ Bad (using forEach)
```typescript
array.forEach((item, index) => {
  console.log(item);
});
```

#### ✅ Good (using for...of)
```typescript
for (const item of array) {
  console.log(item);
}

// With index if needed
for (const [index, item] of array.entries()) {
  console.log(index, item);
}
```

#### ✅ Good (using for...in for objects)
```typescript
for (const key in object) {
  if (Object.prototype.hasOwnProperty.call(object, key)) {
    console.log(key, object[key]);
  }
}
```

## TypeScript Path Aliases

### Current Aliases Configuration
```typescript
// tsconfig.json paths
{
  "@components/*": ["./src/components/*"],
  "@theme/*": ["./src/theme/*"]
}
```

### Usage Guidelines
- **@components/***: Use for importing reusable components from `src/components/`
- **@theme/***: Use for importing theme-related files from `src/theme/`
- **Relative paths**: Only use for child directories, never for parent directories
- **No @ prefix**: Do not create aliases without the @ prefix to avoid conflicts

### Examples

#### ✅ Good (using aliases)
```typescript
// Importing from components
import { Button } from '@components/button';
import { UserProfile } from '@components/user-profile';

// Importing from theme
import { colors } from '@theme/colors';
import { typography } from '@theme/typography';

// Child directory import (relative path allowed)
import { HeroSection } from './_components/hero-section';
```

#### ❌ Bad (incorrect path usage)
```typescript
// Using relative paths to parent directories
import { Button } from '../../../components/button'; // ❌ Use @components/button instead
import { colors } from '../../theme/colors'; // ❌ Use @theme/colors instead

// Missing aliases
import { UserProfile } from 'src/components/user-profile'; // ❌ Use @components/user-profile
```

## Testing Guidelines

### Test-Driven Development (TDD)
- **ALWAYS write tests before implementing features**
- Follow the Red-Green-Refactor cycle:
  1. Write failing tests first
  2. Implement minimal code to make tests pass
  3. Refactor while keeping tests green

### Test Execution
- **ALWAYS use `pnpm exec vitest run` for test execution in singleshot mode**
- This project uses pnpm as the package manager
- Use `pnpm exec vitest run` for CI/automated testing
- Use `pnpm exec vitest` for development/watch mode

### Views Testing Exception
- Views components (React components in `page.tsx` `layout.tsx`) do NOT require vitest tests
- Focus testing efforts on business logic, services, and API endpoints
- UI testing should be done through other means (e.g., manual testing, E2E tests)

## Vanilla Extract Styling

### File Naming
- **Style files**: Always use `.css.ts` extension
- **Co-location**: Place style files next to their corresponding component files

### Allowed Packages
- **@vanilla-extract/css**: Core styling functionality
- **@vanilla-extract/css-utils**: Utility functions
- **@vanilla-extract/dynamic**: Dynamic styling support

### Avoided Packages
- **@vanilla-extract/recipes**: Do not use - prefer explicit style composition
- **@vanilla-extract/sprinkles**: Do not use - prefer explicit style definitions

### Style Organization
- Use `style()` for component-specific styles
- Use style composition with arrays for variants
- Use `globalStyle()` for global styles (in layout files only)
- Use `assignInlineVars()` from `@vanilla-extract/dynamic` for dynamic values

### Examples

#### ✅ Good (vanilla extract core usage)
```typescript
// styles.css.ts
import { style } from '@vanilla-extract/css';

export const buttonBase = style({
  padding: '8px 16px',
  border: 'none',
  borderRadius: '4px',
  cursor: 'pointer',
  fontSize: '14px',
  fontWeight: '500',
  transition: 'all 0.2s ease-in-out',
});

export const buttonPrimary = style([buttonBase, {
  backgroundColor: '#0070f3',
  color: 'white',
}]);

export const buttonSecondary = style([buttonBase, {
  backgroundColor: '#f4f4f4',
  color: '#333',
  border: '1px solid #ddd',
}]);
```

#### ✅ Good (dynamic styling when needed)
```typescript
// styles.css.ts
import { style } from '@vanilla-extract/css';

export const dynamicButton = style({
  backgroundColor: 'var(--button-bg-color)',
  color: 'var(--button-text-color)',
});

// Component usage
import { assignInlineVars } from '@vanilla-extract/dynamic';

<button 
  className={dynamicButton}
  style={assignInlineVars({
    '--button-bg-color': isActive ? '#0070f3' : '#f4f4f4',
    '--button-text-color': isActive ? 'white' : '#333',
  })}
>
  Dynamic Button
</button>
```

## Package Management

### pnpm Usage
- **This project uses pnpm as the package manager**
- Use `pnpm install` instead of `npm install`
- Use `pnpm exec` prefix for executing package scripts
- Respect the workspace configuration in `pnpm-workspace.yaml`

### Script Execution
```bash
# Development
pnpm dev

# Testing
pnpm test
pnpm test:watch

# Building
pnpm build

# Deployment
pnpm deploy
```

## Interface vs Type Guidelines

### Use `type` for Data Structures, `interface` for Behavior Contracts
- **Use `type` for pure data structures without behavior**
- **Use `interface` for contracts that define behavior (methods, functions)**
- Data structures represent shape of objects, while interfaces represent contracts

### Examples

#### ✅ Good (using type for data structures)
```typescript
// Pure data structures - use type
type User = {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
};

type ApiResponse = {
  data: User[];
  status: number;
  message: string;
};

type EventInstance = {
  id: number;
  name: string;
  capacity: number;
  invitees: User[];
};
```

#### ✅ Good (using interface for behavior contracts)
```typescript
// Behavior contracts - use interface
interface UserService {
  create(userData: User): Promise<User>;
  update(id: string, data: Partial<User>): Promise<User>;
  delete(id: string): Promise<void>;
}

interface EventHandler {
  handle(event: Event): void;
  canHandle(event: Event): boolean;
}

interface Repository<T> {
  save(entity: T): Promise<T>;
  findById(id: string): Promise<T | null>;
  delete(id: string): Promise<void>;
}
```

## Namespace and Interface Naming Guidelines

### Avoid Redundant Naming in Namespaced Contexts
- **NEVER repeat the namespace/interface name in method names**
- When methods are already scoped within a namespace or interface, avoid redundant prefixes
- Keep method names concise and focused on their action

### Examples

#### ❌ Bad (redundant naming)
```typescript
interface StaffService {
  addStaff(userId: string): ResultAsync<void, ApplicationError>;
  removeStaff(userId: string): ResultAsync<void, ApplicationError>;
  isStaff(userId: string): ResultAsync<boolean, ApplicationError>;
}
```

#### ✅ Good (concise naming)
```typescript
interface StaffService {
  add(userId: string): ResultAsync<void, ApplicationError>;
  remove(userId: string): ResultAsync<void, ApplicationError>;
  is(userId: string): ResultAsync<boolean, ApplicationError>;
}
```